1. 方法的重载：
    方法的重载是通过参数列表的不同来完成的，你甚至可以通过参数顺序不同来区分两个方法，尽管这可能会造成混乱，但是你不能通过返回值来重载，
    因为某些方法的调用并不关心返回值，所以编译器就不知道要调用哪个方法了。
    
2. 无参构造器：
    一个无参构造器就是不接受任何参数的构造器，用来创建一个`默认的对象`,如果你创建一个类，类中没有构造器，那么编译器会自动为你创建一个
    无参构造器。
    
3. this关键字：
    假设在方法的内部，你想获得当前对象的引用。但是，对象引用是被秘密的传达给编译器的(并不在参数列表之中)。这就用到了`关键字this`,this
    只能在`非静态方法`内部使用,当你调用一个对象方法时，this生成了一个对象引用，你可以像对待其他引用一样对待这个引用。如果你在一个类的方法
    里调用该类的其他的方法，不用使用this，直接调用即可，this已经自动应用于其他的方法上了。
    当你在一个类中写了多个构造器，有时候你想在一个构造器中调用另一个构造器来避免代码重复。你可以通过this关键字实现这样的调用。（只能通过
    this关键字调用一次构造器，另外必须首先调用构造器，否则编译器会报错）。
    
    记住this关键字的使用，你会对static修饰的方法有更加深入的理解，static方法中不存在this,你不能在静态方法中调用非静态方法(反之可以)。
    静态方法是为了类而设计的，不需要任何对象。
    
4. 垃圾回收器：
    垃圾回收器只会释放new创建的对象的内存，又因为new创建的对象内存分配在堆内存中，所以垃圾回收器只会释放堆内存。这就造成了栈内存等其他
    地方的内存无法释放，为了处理这种情况，Java允许在类中定义一个名为`finalize()`的方法。
    他的工作原理假定是这样的：当垃圾回收器准备回收对象的内存时，首先会调用其`finalize()`方法，并在下一轮垃圾回收动作发生时，才会真正回收
    对象占用的内存。所以如果你打算使用`finalize()`就能在垃圾回收时做一些重要的清理工作。
    在Java中，对象并非总是被垃圾回收：
    (1).对象可能不被垃圾回收。
    (2).垃圾回收不等同于C++的析构。
    (3).垃圾回收只与内存有关。
    例如：
    本地方法Native Method是一种用Java直接调用非Java语言代码的形式。本地方法目前只支持(C和C++但是他们可以调用其他语言的代码，所以实际
    上可以调用任何代码)。在非Java代码中，也许你会调用C语言的`malloc()`函数系列来分配存储空间，而且除非调用`free()`函数，不然存储空间永远
    得不到释放，造成内存泄露。但是`free()`函数是C和C++中的函数，所以你需要在`finalize()`方法里用本地方法调用它。所以`finalize()`并不
    常用。
    
    **注意：** 无论`垃圾回收`还是`终结`，都不保证一定会发生。如果JVM并未面临内存耗尽的情形，他可能不会浪费时间执行垃圾回收以恢复内存。
    
    **注意：** System.gc();用于强制终结。 super.finalize();最终调用Object中的finalize()方法。

5. 构造器初始化：
    构造器初始化有更大的灵活性，因为你可以在运行时调用方法进行初始化。但是，这无法阻止自动初始化的进行，他会在构造器被调用之前发生。
    
6. 静态数据的初始化：
    无论创建多少个对象，静态数据都只占用一份存储区域。`static关键字`不能应用于局部变量，如果一个字段是静态的基本类型，你没有初始化，就会
    活的基本类型的标准初值，引用类型则为null.
    `即使没有显式的使用static关键字，构造器实际上也是静态方法。`
    
7. 数组的初始化：
    ```java
    int[] arr = {1, 2, 3, 4, 5};
    ```
    这种特殊的初始化是由一堆花括号括起来的值组成。这种情况下，存储空间的分配(相当于使用new)将由编译器负责。
    
    在Java中可以将一个数组赋值给另一个数组，但是，真正做的只是复制了一个引用。两个数组的引用对应同一个存储空间。
    
8. 枚举类型：
    枚举类型(enum)有一个很使用的特性，就是在switch语句中使用。
    