1. Java虽然万物皆可为对象，但是我们实际操控的标志符只是`对象的引用`。当仅仅有一个`引用`并不代表必然有一个与之关联的对象，但是，更加安全
的做法是，创建一个引用的同时进行初始化--指向任意对象。

2. 数据存储：程序运行时如何存储的呢？内存怎么分配？下面五个不同的地方可以存储数据
    ①`寄存器`：最快的存储区域，位于CPU内部，然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法
    在自己的程序里找到寄存器存在的踪迹。(C/C++允许开发者向编译器建议寄存器的分配)。
    
    ②`栈内存`：存在于常规内存RAM(随机访问存储器，Random Access Memory)区域中，可通过栈指针获取处理器的直接支持。栈指针下移分配内存
    上移释放内存。这是一种仅次于寄存器的非常快速有效的分配存储方式。创建程序时，Java系统必须知道栈内存的所有项的生命周期。这种约束限制了
    程序的灵活性。`因此，虽然在栈内存上存在一些Java数据(如对象的引用),但Java对象本身的数据却是存在堆内存中的。`
    
    ③`堆内存`: 这是一种通用的内存池(也在RAM区域)，所有Java对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长
    时间。因此，用堆内存保存数据更具有灵活性。创建一个对象时，只需要用 `new` 关键字实例化对象即可，当执行代码时，会自动在堆中进行内存
    分配。这种灵活性是有代价的，分配和清理堆内存要比栈内存需要更多的时间(如果可以用Java在栈内存上创建对象的前提下，就像在C++中那样)。
    但是随着时间的推移，Java的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。
    
    ④`常量存储`：常量值通常直接放在程序代码中，因此他们永远不会改变。如需要严格保护，可考虑将他们置于只读存储器ROM中(Read Only Memory)
    
    ⑤`非RAM存储`：数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：(1)序列化对象：对象被转化为字节流。
    通常被发送到另一台机器；(2)持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。这些存储的方式都是将对象转存于另一个介质中，
    并在需要时恢复成常规的、基于RAM的对象。Java为轻量级持久化提供了支持。而诸如JDBC和Hibernate这些类库为使用数据库存储和检索对象信息
    提供了更复杂的支持。

3. 基本数据类型的存储：基本数据类型不需要使用 `new` 关键字创建，而是使用一个自动变量，这个变量直接存储值，并置于`栈内存中`
    ![内存占用大小](https://yunqing-img.oss-cn-beijing.aliyuncs.com/hexo/article/202011/16-int-01.png)
    
4. 数组的存储：
    在Java中，数据使用前需要被初始化，并且不能访问数组长度意外的数据。这种范围检查，是以每个数组上少量的内存开销及运行时检查下表的额外
    时间为代价的，但是因此换来的安全性和效率的提高是值得的。
    当我们创建对象数组时，实际上是创建了一个引用数组，每个引用的初始值都是`null`,例如基本数据类型数组，编辑器会用过将该数组全部置零来
    保证初始化。

5. 对象的作用域：
    Java对象与基本数据类型有不同的声明周期。基本数据类型的声明周期在大括号内，但是当我们使用`new`关键字创建对象时，他的声明周期将会超出
    作用域。
    ```java
   {
       String s = new String("Java编程思想");
   }
   // 作用域终点
    ```
    上例中，引用 s 在作用域终点就结束了。但是引用 s 指向的字符串对象依然还在占用内存。只要你需要，`new`出来的对象就会一直存活下去。Java
    的垃圾收集器会检查哪些对象不再可达，然后释放其所占用的内存，不需要程序员去关心内存的释放。

6. Java中对象参数传递，实际上并没有直接处理对象，而是在传递对象的引用。

7. 当返回类型为 void 时， return 关键字仅用于退出方法，因此在方法结束处的 return 可被省略。

8. static关键字：
    (1).有时候你只想为特定的字段分配一个共享存储空间，而不去考虑究竟要创建多少个对象，甚至根本不创建对象。
    (2).创建一个与此类的任何对象无关的方法。也就是说，及时没有创建对象，也能调用该方法。
    `static`关键字就符合以上两点要求。
    ```java
    class StaticTest {
       static int i = 47;   
    }
    // 现在即使你创建两个对象引用，静态变量 i 也只占一份存储空间。两个对象都会共享相同的变量 i
    ```
   
